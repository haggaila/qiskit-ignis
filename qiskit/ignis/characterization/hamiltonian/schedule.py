# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2019.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""
Schedule generation for measuring hamiltonian parametes
"""

from copy import deepcopy
from typing import List, Tuple, Optional, Dict, Callable

import numpy as np
import qiskit.pulse.pulse_lib as pulse_lib
from qiskit import pulse, circuit, transpile, schedule, QuantumCircuit, QuantumRegister
from qiskit.ignis.characterization import CharacterizationError
from qiskit.ignis.verification.tomography.basis.circuits import state_tomography_circuits
from qiskit.providers import BaseBackend
from qiskit.pulse import CmdDef, Schedule, PulseError
from qiskit.pulse.channels import Channel


_duration_obj = circuit.Parameter('dur')


def cr_hamiltonian_tomography_schedules(c_qubit: int,
                                        t_qubit: int,
                                        cr_circ: QuantumCircuit,
                                        cr_durations: np.ndarray,
                                        backend: BaseBackend,
                                        cmd_def: CmdDef,
                                        basis_gates: List[str]) -> List[Schedule]:
    """
    Generate ``Schedule``s for measuring CR Hamiltonian [1].
    Measuring ``cr_circ`` in all Pauli basis with initial states |00> and |01>.
    Partial tomography on target qubit yields information of CR Hamiltonian.

    Circuit should be parametrized with cr pulse duration, and can be
    generated by using helper function ``create_cr_circuit``.
    This function adds state preparation and measurement schedules to ``cr_circ``,
    and finally convert the circuits into pulse ``Schedule``s executable as a pulse job.
    Schedules should be executed with `meas_level=2`, or use discriminator to get counts.

    Args:
        c_qubit: index of control qubit.
        t_qubit: index of target qubit.
        cr_circ: parametrized circuit to generate CR Rabi oscillation.
        cr_durations: array of pulse durations.
        backend: backend object of target system.
        cmd_def: extended command definition.
        basis_gates: extended basis gates.

    Returns:
        schedules: experiments to run.

    Example:
        .. jupyter-execute::

           from qiskit import QuantumCircuit
           from qiskit import quantum_info as qi
           from qiskit.visualization import plot_process_city
           %matplotlib inline

           qc = QuantumCircuit(2)
           qc.cx(0, 1)

           plot_quantum_channel_hinton(qc, title="New Hinton Plot")
    """
    circ_names = ['cr_ham_tomo_sched_%d' % ii for ii in range(len(cr_durations))]

    # extract quantum registers
    qr = cr_circ.qregs[0]
    qr_c = qr[c_qubit]
    qr_t = qr[t_qubit]

    # generate tomography sequence
    cr_circs = []
    for cind, cr_duration in enumerate(cr_durations):
        for c_state in (0, 1):
            qc = QuantumCircuit(qr)
            # flip control qubit
            if c_state:
                qc.x(qr_c)
                qc.barrier(qr)
            # bind parameter
            qc += cr_circ.bind_parameters({_duration_obj: cr_duration})
            # add measurement circuit
            qst_qcs = state_tomography_circuits(qc, [qr_t])
            for qsc_qc, label in zip(qst_qcs, ['x', 'y', 'z']):
                qsc_qc.name = '%s_%s_%s' % (circ_names[cind], label, c_state)

            cr_circs.extend(qst_qcs)

    cr_basis_circs = transpile(cr_circs, backend, basis_gates, optimization_level=0)

    return schedule(cr_basis_circs, backend, cmd_def)


def create_cr_circuit(c_qubit: int,
                      t_qubit: int,
                      backend: BaseBackend,
                      cross_resonance_params: Dict[str, float],
                      use_echo: bool = True,
                      cmd_def: Optional[CmdDef] = None,
                      basis_gates: Optional[List[str]] = None) \
        -> Tuple[QuantumCircuit, CmdDef, List[str]]:
    """
    A helper function to generate cross resonance circuits with variable pulse duration.
    Gaussian flattop pulse parameter should be defined as a python dictionary to
    generate cross resonance and cancellation pulses from ``gaussian_square`` pulses.
    
    ```python
    cross_resonance_params = {'cr_amp': 0.1, 'ca_amp': 0.1, 'sigma': 5, 'risefall': 30}
    ```
    
    This function converts pulse sequence into ``QuantumCircuit`` and returns it with
    new pulse command definition and basis gates to be provided to the pulse scheduler
    and transpiler to revert the circuit into pulse schedule.
    
    Args:
        c_qubit: index of control qubit.
        t_qubit: index of target qubit.
        backend: backend object of target system.
        cross_resonance_params: python dictionary of cross resonance pulse arguments
        use_echo: use echo sequence if ``True``.
        cmd_def: command definition. use backend default if not provided.
        basis_gates: list of basis gate names.
    
    Returns:
        ``QuantumCircuit``, pulse command definition, and extended basis gates.
    """
    back_config = backend.configuration()
    defaults = backend.defaults()

    # get command definition and basis gates
    if not cmd_def:
        cmd_def = pulse.CmdDef.from_defaults(defaults.cmd_def, defaults.pulse_library)
    extended_cmd_def = deepcopy(cmd_def)

    if not basis_gates:
        basis_gates = back_config.basis_gates
    extended_basis = deepcopy(basis_gates)

    # get channel instances
    c_drive, t_drive, cr_drive = _get_channels(c_qubit, t_qubit, backend, extended_cmd_def)

    # create custom pulse definition, new command definition and basis gates
    cr_sched_p = _cr_designer_variable_duration(cross_resonance_params,
                                                cr_drive, c_drive, t_drive,
                                                negative=False)
    cr_sched_m = _cr_designer_variable_duration(cross_resonance_params,
                                                cr_drive, c_drive, t_drive,
                                                negative=True)

    extended_cmd_def.add('zx_p', qubits=[c_qubit, t_qubit], schedule_generator=cr_sched_p)
    extended_cmd_def.add('zx_m', qubits=[c_qubit, t_qubit], schedule_generator=cr_sched_m)

    extended_basis.extend(['zx_p', 'zx_m'])

    # create custom gate
    def cr_p_circ(param):
        return circuit.Gate(name='zx_p', num_qubits=2, params=[param])

    def cr_m_circ(param):
        return circuit.Gate(name='zx_m', num_qubits=2, params=[param])

    # create parametrized circuit
    qr = QuantumRegister(back_config.n_qubits)
    qc = QuantumCircuit(qr)

    qr_c = qr[c_qubit]
    qr_t = qr[t_qubit]

    if use_echo:
        qc.append(cr_p_circ(_duration_obj), qargs=[qr_c, qr_t])
        qc.x(qr_c)
        qc.append(cr_m_circ(_duration_obj), qargs=[qr_c, qr_t])
        qc.x(qr_c)
    else:
        qc.append(cr_p_circ(_duration_obj), qargs=[qr_c, qr_t])

    return qc, extended_cmd_def, extended_basis


def _cr_designer_variable_duration(sched_params: Dict[str, float],
                                   cr_drive: Channel,
                                   c_drive: Channel,
                                   t_drive: Channel,
                                   negative: bool = False) -> Callable:
    """
    Create parametrized cross resonance schedule with variable pulse duration.

    Args:
        sched_params: parameters to construct schedule.
        cr_drive: control channel object.
        c_drive: control qubit drive channel object.
        t_drive: target qubit drive channel object.
        negative: flip cross resonance pulse if ``True``.
    """
    # get valid cross resonance pulse parameters
    valid_pnames = 'cr_amp', 'ca_amp', 'sigma', 'risefall'
    valid_params = {pname: sched_params.get(pname, 0) for pname in valid_pnames}
    if negative:
        cr_amp = -valid_params.pop('cr_amp')
        ca_amp = -valid_params.pop('ca_amp')
    else:
        cr_amp = valid_params.pop('cr_amp')
        ca_amp = valid_params.pop('ca_amp')

    # parametrized cr schedule without cancellation
    def cr_sched_parametrized(duration):
        valid_params['duration'] = duration
        # cross resonance pulse
        cr_params = deepcopy(valid_params)
        cr_params['amp'] = cr_amp
        cr_params['name'] = 'CR90%s_u_var' % 'm' if negative else 'p'
        # cancellation pulse
        ca_params = deepcopy(valid_params)
        ca_params['amp'] = ca_amp
        ca_params['name'] = 'CR90%s_d_var' % 'm' if negative else 'p'

        sched = pulse.Schedule()
        sched = sched.union((0, pulse_lib.gaussian_square(**cr_params)(cr_drive)))
        sched = sched.union((0, pulse.Delay(duration)(c_drive)))
        if ca_amp != 0:
            sched = sched.union((0, pulse_lib.gaussian_square(**ca_params)(t_drive)))
        else:
            sched = sched.union((0, pulse.Delay(duration)(t_drive)))
        return sched

    return cr_sched_parametrized


def _get_channels(c_qubit: int,
                  t_qubit: int,
                  backend: BaseBackend,
                  cmd_def: Optional[CmdDef] = None) -> Tuple[Channel, Channel, Channel]:
    """
    A helper function to generate channel instance list.

    Args:
        c_qubit: index of control qubit.
        t_qubit: index of target qubit.
        backend: backend object of target system.
        cmd_def: command definition of target system if customized.

    Returns:
        c_drive: `DriveChannel` instance that drives control qubit.
        t_drive: `DriveChannel` instance that drives target qubit.
        cr_drive: `ControlChannel` instance that drives cross resonance.
    """
    back_default = backend.defaults()
    back_config = backend.configuration()
    if not cmd_def:
        cmd_def = pulse.CmdDef.from_defaults(back_default.cmd_def, back_default.pulse_library)

    try:
        cx_ref = cmd_def.get('cx', qubits=(c_qubit, t_qubit))
    except PulseError:
        raise CharacterizationError('Cross resonance is not defined for qubits %d-%d.' % (c_qubit, t_qubit))

    cx_ref = cx_ref.filter(instruction_types=[pulse.commands.PulseInstruction])
    for channel in cx_ref.channels:
        if isinstance(channel, pulse.ControlChannel):
            cr_drive = channel
            break
    else:
        raise CharacterizationError('No valid control channel to drive cross resonance.')
    c_drive = back_config.drive(c_qubit)
    t_drive = back_config.drive(t_qubit)

    return c_drive, t_drive, cr_drive
