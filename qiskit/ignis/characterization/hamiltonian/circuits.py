# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2019.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""
Circuit generation for measuring hamiltonian parametes
"""
from copy import deepcopy
from typing import Tuple, List, Dict, Optional

import numpy as np
import qiskit
from qiskit import QuantumCircuit
from qiskit.ignis.characterization.pulse_library import (cr_designer_variable_duration,
                                                         var_duration,
                                                         get_control_channels)
from qiskit.ignis.verification.tomography.basis.paulibasis import pauli_measurement_circuit
from qiskit.providers import BaseBackend
from qiskit.pulse import InstructionScheduleMap

from ..characterization_utils import pad_id_gates


def zz_circuits(num_of_gates, gate_time, qubits, spectators, nosc=5):
    """
    Generates circuit for measuring ZZ.
    Two Ramsey experiments, the first with the spectator in the
    ground state, the second with the spectator in the excited state

    Args:
        num_of_gates (list of integers): the number of identity gates in each
            circuit. Must be in an increasing order.
        gate_time (float): time of running a single gate.
        qubits (list of integers): indices of the qubits to measure and
            perform the Ramsey
        spectators (list of integers): indices of the qubits to flip the
            state (ie measure the ZZ between qubits and spectators). Must
            be the same length as qubits
        nosc: number of oscillations to induce using the phase gate

    Returns:
        A list of QuantumCircuit
        xdata: a list of delay times
        osc_freq: the induced oscillation frequency
    """

    if len(qubits) != len(spectators):
        raise ValueError("Number of qubits and spectators must be the same")

    for _, qubit in enumerate(qubits):
        if qubit in spectators:
            raise ValueError("Qubits and spectators must be different")

    xdata = gate_time * num_of_gates

    qr = qiskit.QuantumRegister(max([max(qubits), max(spectators)])+1)
    cr = qiskit.ClassicalRegister(len(qubits))

    osc_freq = nosc/xdata[-1]

    circuits = []

    for qflip in [False, True]:
        for circ_index, circ_length in enumerate(num_of_gates):
            circ = qiskit.QuantumCircuit(qr, cr)
            circ.name = 'zzcircuit_' + str(circ_index) + '_%d' % qflip
            for _, qspec in enumerate(spectators):
                if qflip:
                    circ.x(qr[qspec])
            circ.barrier(qr)
            for qind, qubit in enumerate(qubits):
                circ.h(qr[qubit])
                circ = pad_id_gates(circ, qr, qubit, circ_length)
                circ.u1(2*np.pi*osc_freq*xdata[circ_index], qr[qubit])
                circ.h(qr[qubit])
            circ.barrier(qr)
            for qind, qubit in enumerate(qubits):
                circ.measure(qr[qubit], cr[qind])
            circuits.append(circ)

    return circuits, xdata, osc_freq


def cr_hamiltonian_tomography_circuits(qubit_pair: Tuple[int, int],
                                       cr_circ: QuantumCircuit,
                                       cr_durations: np.ndarray,
                                       resolution: float) \
        -> Tuple[List[QuantumCircuit], np.ndarray]:
    """
    Generate ``QuantumCircuit`` to measure CR Hamiltonian [1].
    Measuring ``cr_circ`` in all Pauli basis with initial states |00> and |01>.
    Partial tomography on target qubit yields information of CR Hamiltonian.

    Circuit should be parametrized with cr pulse duration, and this can be
    generated by using helper function ``create_cr_circuit``.

    This function adds state preparation and measurement schedules to ``cr_circ``.
    Returned circuit should be transpiled and scheduled to execute as a pulse job.
    Schedules should be executed with `meas_level=2`, or use discriminator to get counts.

    See the example about how you can run the experiment.

    Args:
        qubit_pair: index of control and target qubit to measure.
        cr_circ: parametrized circuit to generate CR Rabi oscillation.
        cr_durations: array of pulse durations.
        resolution: dt of given duration.

    Returns:
        schedules: experiments to run.

    Example:
        .. jupyter-execute::

           import qiskit
           from qiskit.ignis.characterization.hamiltonian import *

           provider = qiskit.IBMQ.get_provider()
           backend = provider.get_backend('my_ibmq_backend')

           params = {'cr_amp': 0.1, 'sigma': 5, 'risefall': 20}
           durations = [100, 200, 300]

           qc, maps, gates = create_cr_circuit((0, 1), backend, params)
           rabi_qcs = cr_hamiltonian_tomography_schedules((0, 1), qc, durations)

           rabi_qcs = qiskit.transpile(rabi_qcs, backend, basis_gates=gates)
           scheds = qiskit.schedule(rabi_qcs, backend, maps)
    """
    circ_names = ['cr_ham_tomo_sched_%d' % ii for ii in range(len(cr_durations))]
    qreg = cr_circ.qregs[0]
    creg = qiskit.ClassicalRegister(qreg.size)

    c_qubit, t_qubit = qubit_pair

    # generate tomography sequence
    cr_circs = []
    for cind, cr_duration in enumerate(cr_durations):
        for c_state in (0, 1):
            qc = qiskit.QuantumCircuit(qreg, creg)
            # flip control qubit
            if c_state:
                qc.x(qreg[c_qubit])
            qc.barrier(qreg)
            # bind parameter
            qc += cr_circ.bind_parameters({var_duration: cr_duration})
            # measure
            qc.barrier(qreg)
            for op in ('X', 'Y', 'Z'):
                qc_temp = qc.copy()
                qc_temp += pauli_measurement_circuit(op, qreg[t_qubit], creg[0])
                cname = '%s_%s_%s' % (circ_names[cind], op, c_state)
                qc_temp.name = cname.lower()
                cr_circs.append(qc_temp)

    xdata = resolution * np.asarray(cr_durations, dtype=float)

    return cr_circs, xdata


def create_cr_circuit(qubit_pair: Tuple[int, int],
                      backend: BaseBackend,
                      cross_resonance_params: Dict[str, float],
                      use_echo: bool = True,
                      circ_inst_map: Optional[InstructionScheduleMap] = None,
                      basis_gates: Optional[List[str]] = None) \
        -> Tuple[QuantumCircuit, InstructionScheduleMap, List[str]]:
    """
    A helper function to generate circuit abstraction of CR with variable pulse duration.
    Gaussian flattop pulse parameter should be defined as a python dictionary to
    generate cross resonance and cancellation pulses from ``gaussian_square`` pulses.

    ```python
    cross_resonance_params = {'cr_amp': 0.1, 'ca_amp': 0.1, 'sigma': 5, 'risefall': 30}
    ```

    This function converts pulse sequence into ``QuantumCircuit`` and returns it with
    new pulse command definition and basis gates to be provided to the pulse scheduler
    and transpiler to revert the circuit into pulse schedule.

    Args:
        qubit_pair: index of control and target qubit.
        backend: backend object of target system.
        cross_resonance_params: python dictionary of cross resonance pulse arguments
        use_echo: use echo sequence if ``True``.
        circ_inst_map: mapper of circuit to instructions. use backend default if not provided.
        basis_gates: list of basis gate names.

    Returns:
        ``QuantumCircuit``, pulse command definition, and extended basis gates.
    """
    back_config = backend.configuration()
    back_defaults = backend.defaults()

    c_qubit, t_qubit = qubit_pair

    # get command definition and basis gates
    if not circ_inst_map:
        circ_inst_map = back_defaults.circuit_instruction_map
    extended_map = deepcopy(circ_inst_map)

    if not basis_gates:
        basis_gates = back_config.basis_gates
    extended_basis = deepcopy(basis_gates)

    # get control channel index
    u_index = get_control_channels(c_qubit, t_qubit, extended_map)

    # create custom pulse definition, new command definition and basis gates
    cr_sched_p = cr_designer_variable_duration(cross_resonance_params,
                                               c_qubit, t_qubit, u_index,
                                               negative=False)
    cr_sched_m = cr_designer_variable_duration(cross_resonance_params,
                                               c_qubit, t_qubit, u_index,
                                               negative=True)

    extended_map.add('zx_p', qubits=[c_qubit, t_qubit], schedule=cr_sched_p)
    extended_map.add('zx_m', qubits=[c_qubit, t_qubit], schedule=cr_sched_m)

    extended_basis.extend(['zx_p', 'zx_m'])

    # create custom gate
    def cr_p_circ(param):
        return qiskit.circuit.Gate(name='zx_p', num_qubits=2, params=[param])

    def cr_m_circ(param):
        return qiskit.circuit.Gate(name='zx_m', num_qubits=2, params=[param])

    # create parametrized circuit
    qr = qiskit.QuantumRegister(back_config.n_qubits)
    qc = qiskit.QuantumCircuit(qr)

    qr_c = qr[c_qubit]
    qr_t = qr[t_qubit]

    if use_echo:
        qc.append(cr_p_circ(var_duration), qargs=[qr_c, qr_t])
        qc.x(qr_c)
        qc.append(cr_m_circ(var_duration), qargs=[qr_c, qr_t])
        qc.x(qr_c)
    else:
        qc.append(cr_p_circ(var_duration), qargs=[qr_c, qr_t])

    return qc, extended_map, extended_basis
